#!/usr/bin/env python3
"""
Main driver node for the OnRobot RG2-FT gripper
"""

import sys

# ros imports
import rospy
from std_msgs.msg import Bool, Float32, Header
from sensor_msgs.msg import JointState
from rg2_msgs.msg import GripperCommand
from geometry_msgs.msg import Vector3, Wrench, WrenchStamped

# modbus imports
from pymodbus.client.sync import ModbusTcpClient

# threading to deal with background tasks
from threading import Lock, Thread

import math

MODBUS_FN_CODES = {
    'read_holding_reg'      : 0x03,
    'write_single_reg'      : 0x06,
    'write_multi_reg'       : 0x10,
    'rw_multi_reg'          : 0x17,
}

MODBUS_REGISTERS = {
    'target_force'                  : 0x0000,   # w 0.1%, 0-1000
    'target_diameter'               : 0x0001,   # w 0.1mm
    'grip_type'                     : 0x0002,   # w 0=external, 1=internal
    'control'                       : 0x0003,   # w see below
    'status'                        : 0x0100,   # r bit-field, see below
    'raw_diameter'                  : 0x0101,   # r 0.1mm
    'diameter_w_fintertip_offset'   : 0x0102,   # r 0.1mm signed 2s-compliment
    'force_applied'                 : 0x0103,   # r 0.1%
    'finger_angle'                  : 0x0105,   # r 0.001 rad, 0 = fully-open
    'finger_length'                 : 0x010e,   # r 0.1mm
    'finger_position'               : 0x0110,   # r finger mount type: 1, 2, or 3
    'fingertip_offset'              : 0x0111,   # r 0.01mm
    'min_diameter'                  : 0x0201,   # r 0.1mm
    'max_diameter'                  : 0x0202,   # r 0.1mm
    'set_finger_length'             : 0x0401,   # rw 0.1mm
    'set_finger_position'           : 0x0403,   # rw set finger mount type 1, 2, or 3
    'set_fingertip_offset'          : 0x0404    # rw 0.01mm
}

RG2_FT_REGISTERS = {
    'zero'                  : 0x0000,   # rw zero force & torque sensors to cancel offset: 0x0000: unzero, 0x0001: zero
    'target_force'          : 0x0002,   # w 0.1N, 0-400
    'target_width'          : 0x0003,   # w 0.01mm, 0-1000
    'control'               : 0x0004,   # w 0x0000: stop, 0x0001: grip
    'proximity_offset_l'    : 0x0005,   # rw 0.1mm, subtracted from raw signal
    'proximity_offset_r'    : 0x0006,   # rw same as above
    'status_l'              : 0x0101,   # r 0x0000 when no error in left finger
    'fx_l'                  : 0x0103,   # r 0.1N force along the X axis of the left finger, signed
    'fy_l'                  : 0x0104,   # r 0.1N force along the Y axis of the left finger, signed
    'fz_l'                  : 0x0105,   # r 0.1N force along the Z axis of the left finger, signed
    'tx_l'                  : 0x0106,   # r 0.01Nm torque around X axis of left finger, signed
    'ty_l'                  : 0x0107,   # r 0.01Nm torque around Y axis of left finger, signed
    'tz_l'                  : 0x0108,   # r 0.01Nm torque around Z axis of left finger, signed
    'status_r'              : 0x010a,   # r same as above, but for right finger
    'fx_r'                  : 0x010c,   # r same as above, but for right finger
    'fy_r'                  : 0x010d,   # r same as above, but for right finger
    'fz_r'                  : 0x010e,   # r same as above, but for right finger
    'tx_r'                  : 0x010f,   # r same as above, but for right finger
    'ty_r'                  : 0x0110,   # r same as above, but for right finger
    'tz_r'                  : 0x0111,   # r same as above, but for right finger
    'proximity_status_l'    : 0x0112,   # r 0x0000 when no error with left proximity sensor
    'proximity_value_l'     : 0x0113,   # r 0.1mm distance to left proximity sensor, signed
    'proximity_status_r'    : 0x0115,   # r as above, but for right proximity sensor
    'proximity_value_r'     : 0x0116,   # r as above, but for right proximity sensor
    'actual_gripper_width'  : 0x0118,   # r 0.1mm current width between grippers
    'gripper_busy'          : 0x0119,   # r 1 when moving, 0 when still. will only accept new commands when 0
    'grip_detected'         : 0x011a    # r 1 when an internal or external grip is detected, otherwise 0
}

GRIP_TYPES = {
    'grip'      : 0x0001,   # start the motion with preset force & diameter
    'move'      : 0x0002,   # start the motion w/o applying force
    'stop'      : 0x0004    # stop current motion
}

# bit-masks for the status response
STATUS_CODES = {
    'busy'                  : 1<<0,
    'grip_detected'         : 1<<1,
    'force_grip_detected'   : 1<<2,
    'calibration'           : 1<<3
    # bits 4-16 unused
}

def command_callback(data, controller):
    controller.command_callback(data)

class RG2_FT_Node:
    def __init__(self):
        """

        """
        self.load_rosparams()

        if not self.is_sim:
            rospy.loginfo('Creating PyModBus interface for {0}'.format(self))
            self.client = ModbusTcpClient(self.gripper_ip, port=self.gripper_port)
            self.modbus_lock = Lock()
        else:
            rospy.loginfo('Running in simulation mode')
            rospy.logerr('Simulation mode isn\' implemented yet!')
            sys.exit(0)


    def __str__(self):
        if self.is_sim:
            return 'Simulated RG2-F/T'
        else:
            return "RG2-F/T {0}:{1}".format(self.gripper_ip, self.gripper_port)


    def load_rosparams(self):
        self.gripper_name = rospy.get_param('~name', 'gripper')
        self.gripper_ip = rospy.get_param('~ip_address', '192.168.1.1')
        self.gripper_port = rospy.get_param('~tcp_port', 502)
        self.gripper_address = rospy.get_param('~device_address', 65)

        # convert the rate to an actual Rate object we can use to control timing
        self.update_rate = rospy.get_param('~update_rate', 10)
        self.update_rate = rospy.Rate(self.update_rate)

        self.is_sim = rospy.get_param('~sim', False)

        self.base_link_name = '{0}_base_link'.format(self.gripper_name)
        self.joint_names = [
            '{0}_left_finger_joint_1'.format(self.gripper_name),
            '{0}_left_finger_joint_2'.format(self.gripper_name),
            '{0}_right_finger_joint_1'.format(self.gripper_name),
            '{0}_right_finger_joint_2'.format(self.gripper_name)
        ]
        self.fingertip_names = [
            '{0}_left_fingertip'.format(self.gripper_name),
            '{0}_right_fingertip'.format(self.gripper_name)
        ]


    def connect(self):
        self.modbus_lock.acquire()
        if self.client.connect():
            rospy.loginfo('Connected to {0}:{1}'.format(self.gripper_ip, self.gripper_port))
        else:
            rospy.logerr('Failed to connect to {0}'.format(self.gripper_ip))
        self.modbus_lock.release()


    def disconnect(self):
        if not self.is_sim:
            rospy.loginfo('Disconnecting from {0}'.format(self))
            self.modbus_lock.acquire()
            self.client.close()
            self.modbus_lock.release()


    def test_connection(self):
        if self.is_sim:
            rospy.loginfo('Running in simulation mode; no connection to test')
            return True
        else:
            self.modbus_lock.acquire()

            # try reading a value from the gripper to make sure it works
            response = self.client.readwrite_registers(
                read_address=RG2_FT_REGISTERS['actual_gripper_width'], read_count=1,
                write_address=0, write_registers=0,
                unit=self.gripper_address)

            if not response.isError():
                mm = register_to_signed_int(response.registers[0]) * 0.1
                rospy.loginfo('Current gripper width is {0}mm'.format(mm))
            else:
                rospy.logwarn('Failed to read gripper position: {0}'.format(response))

            # try writing position values to move the gripper
            # this is done in 3 steps: fully-open, fully-close, fully-open, ready
            # do this all synchronously
            target_distances = [1000, 0, 1000, 850]
            for d in target_distances:
                response = self.client.write_registers(unit=self.gripper_address,
                    address = RG2_FT_REGISTERS['target_force'], values = [100, d, 1])  # force, width, grip

                if not response.isError():
                    rospy.loginfo('Moving gripper to position gripper {0}'.format(d))
                else:
                    rospy.logwarn('Failed to move gripper: {0}'.format(response))

                rate = rospy.Rate(10)
                is_moving = True
                while is_moving:
                    rate.sleep()
                    response = self.client.read_input_registers(address=RG2_FT_REGISTERS['gripper_busy'], count=1, unit=self.gripper_address)
                    is_moving = not response.isError() and response.registers[0] != 0

            self.modbus_lock.release()


    def start(self):
        self.joint_state_pub = rospy.Publisher('joint_states', JointState, queue_size=1)
        self.grip_width_pub = rospy.Publisher('{0}/width'.format(self.gripper_name), Float32, queue_size=1)
        self.grip_moving_pub = rospy.Publisher('{0}/moving'.format(self.gripper_name), Bool, queue_size=1)
        self.left_fingertip_pub = rospy.Publisher('{0}/left_fingertip'.format(self.gripper_name), WrenchStamped, queue_size=1)
        self.right_fingertip_pub = rospy.Publisher('{0}/right_fingertip'.format(self.gripper_name), WrenchStamped, queue_size=1)

        joint_state_publisher_thread = Thread(target=self.joint_publisher_thread_fn)
        joint_state_publisher_thread.start()

        self.command_sub = rospy.Subscriber('{0}/cmd'.format(self.gripper_name), GripperCommand, command_callback, callback_args=self)


    def joint_publisher_thread_fn(self):
        """
        Background thread that reads the current position of the gripper and publishes the joint state at a fixed rate
        """

        while not rospy.is_shutdown():
            self.update_rate.sleep()
            self.modbus_lock.acquire()
            response = self.client.read_input_registers(address=RG2_FT_REGISTERS['actual_gripper_width'], count=2, unit=self.gripper_address)
            self.modbus_lock.release()

            if not response.isError():
                mm = register_to_signed_int(response.registers[0]) * 0.1
                m = mm * 0.001
                moving = response.registers[1] != 0

                angles = self.do_ik_calculations(mm)

                width = Float32()
                width.data = m
                self.grip_width_pub.publish(width)

                states = JointState()
                states.name = self.joint_names
                states.position = angles
                states.effort = [0.0, 0.0, 0.0, 0.0]
                states.velocity = [0.0, 0.0, 0.0, 0.0]
                states.header = Header()
                states.header.stamp = rospy.Time.now()
                self.joint_state_pub.publish(states)

                is_moving = Bool()
                is_moving.data = moving
                self.grip_moving_pub.publish(is_moving)

            else:
                rospy.logwarn("Failed to read gripper state: {0}".format(response))

            self.modbus_lock.acquire()
            response = self.client.read_input_registers(address=RG2_FT_REGISTERS['fx_l'], count=6, unit=self.gripper_address)
            self.modbus_lock.release()
            self.publish_finger(self.left_fingertip_pub, response, '{0}_left_fingertip'.format(self.gripper_name))

            self.modbus_lock.acquire()
            response = self.client.read_input_registers(address=RG2_FT_REGISTERS['fx_r'], count=6, unit=self.gripper_address)
            self.modbus_lock.release()
            self.publish_finger(self.right_fingertip_pub, response, '{0}_right_fingertip'.format(self.gripper_name))


    def do_ik_calculations(self, distance_mm):
        """
        Return the angles of the 4 finger joints in order [L1, L2, R1, R2] needed to achieve the provided separation
        between the finger joints.

        This doesn't use the TF and instead makes some assumptions about the gripper's joints that may not be
        100% indicative of reality.  This is really just to make sure the gripper's approximate state is
        visible in rviz.

        We assume the fingertips are always kept parallel, with standard fingertips
        """

        if distance_mm < 0:
            distance_mm = 0

        base_finger_offset = 10.0
        link1_length = 57.0
        link2_thickness = 10.0

        try:
            finger_angle = abs( math.asin((distance_mm/2) / link1_length) )
        except ValueError as err:
            # if we have an encoder problem just publish zeros so we have _something_ in the TF
            finger_angle = 0

        return [finger_angle, -finger_angle, finger_angle, -finger_angle]


    def publish_finger(self, topic, response, frame):
        if response.isError():
            rospy.logwarn("Failed to read fingertip sensor data: {0}".format(response))
            return

        fx = register_to_signed_int(response.registers[0]) * 0.1
        fy = register_to_signed_int(response.registers[1]) * 0.1
        fz = register_to_signed_int(response.registers[2]) * 0.1

        tx = register_to_signed_int(response.registers[3]) * 0.01
        ty = register_to_signed_int(response.registers[4]) * 0.01
        tz = register_to_signed_int(response.registers[5]) * 0.01

        msg = WrenchStamped()
        msg.wrench = Wrench()
        msg.wrench.force = Vector3()
        msg.wrench.force.x = fx
        msg.wrench.force.y = fy
        msg.wrench.force.z = fz
        msg.wrench.torque = Vector3()
        msg.wrench.torque.x = tx
        msg.wrench.torque.y = ty
        msg.wrench.torque.z = tz
        msg.header = Header()
        msg.header.stamp = rospy.Time.now()
        msg.header.frame_id = frame

        topic.publish(msg)

    def command_callback(self, data):
        """
        Send commands to the gripper to open/close to the specified distance with the desired force.
        Can also stop the gripper if the stop flag is True
        """
        if data.stop:
            self.modbus_lock.acquire()
            response = self.client.write_registers(address=RG2_FT_REGISTERS['control'], values=[0], unit=self.gripper_address)
            self.modbus_lock.release()

            if response.isError():
                rospy.logwarn("Failed to stop gripper: {0}".format(response))

        else:
            force = int(data.force_n * 10)
            if force > 400:
                rospy.logwarn('Desired force is too high')
                force = 400
            elif force < 0:
                rospy.logwarn('Desired force is too low')
                force = 0

            width = int(data.width_mm * 10)
            if width > 1000:
                rospy.logwarn('Desired width is too large')
                width = 1000
            elif width < 0:
                rospy.logwarn('Desired width is too small')
                width = 0

            self.modbus_lock.acquire()
            response = self.client.write_registers(unit=self.gripper_address,
                address = RG2_FT_REGISTERS['target_force'], values = [force, width, 1])
            self.modbus_lock.release()

def register_to_signed_int(x, base=16):
    """
    Modbus uses 16-bit integers, which can sometimes be treated as a signed 15-bit number.
    This handles converting a signed 16-bit number to a proper int
    Optionally can also work on other bases, but that's not normally needed
    """
    if x & (1 << (base-1)):
        y = x - (1 << base)
    else:
        y = x
    return y

if __name__=='__main__':
    rospy.init_node('rg2_ft_node')

    node = RG2_FT_Node()
    node.connect()
    node.test_connection()
    node.start()
    rospy.spin()
    node.disconnect()
